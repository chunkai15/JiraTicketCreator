// Service to save created ticket history
export class TicketHistoryService {
  
  // Generate markdown content for created tickets
  static generateMarkdownReport(createdTickets, jiraConfig) {
    const timestamp = new Date().toLocaleString();
    const successful = createdTickets.filter(t => t.status === 'success');
    const failed = createdTickets.filter(t => t.status === 'failed');
    
    let markdown = `# Jira Ticket Creation Report\n\n`;
    markdown += `**Generated:** ${timestamp}\n`;
    markdown += `**Project:** ${jiraConfig.projectKey}\n`;
    markdown += `**Jira URL:** ${jiraConfig.url}\n`;
    markdown += `**Created by:** ${jiraConfig.email}\n\n`;
    
    markdown += `## Summary\n\n`;
    markdown += `- **Total Processed:** ${createdTickets.length}\n`;
    markdown += `- **Successful:** ${successful.length}\n`;
    markdown += `- **Failed:** ${failed.length}\n`;
    markdown += `- **Success Rate:** ${createdTickets.length > 0 ? Math.round((successful.length / createdTickets.length) * 100) : 0}%\n\n`;
    
    if (successful.length > 0) {
      markdown += `## ✅ Successfully Created Tickets\n\n`;
      markdown += `| Ticket Key | Title | Jira Link | Attachments |\n`;
      markdown += `|------------|-------|-----------|-------------|\n`;
      
      successful.forEach(ticket => {
        const attachmentCount = ticket.attachments ? ticket.attachments.length : 0;
        const attachmentInfo = attachmentCount > 0 ? `${attachmentCount} files` : 'None';
        markdown += `| **${ticket.ticketKey}** | ${ticket.title} | [View in Jira](${ticket.url}) | ${attachmentInfo} |\n`;
      });
      
      markdown += `\n### Ticket Details\n\n`;
      successful.forEach(ticket => {
        markdown += `#### ${ticket.ticketKey}: ${ticket.title}\n`;
        markdown += `- **Link:** [${ticket.url}](${ticket.url})\n`;
        markdown += `- **Status:** Created successfully\n`;
        if (ticket.attachments && ticket.attachments.length > 0) {
          markdown += `- **Attachments:** ${ticket.attachments.length} files\n`;
          ticket.attachments.forEach(att => {
            markdown += `  - ${att.filename} (${att.success ? '✅ Attached' : '❌ Failed'})\n`;
          });
        }
        markdown += `\n`;
      });
    }
    
    if (failed.length > 0) {
      markdown += `## ❌ Failed Tickets\n\n`;
      markdown += `| Title | Error | Reason |\n`;
      markdown += `|-------|-------|--------|\n`;
      
      failed.forEach(ticket => {
        markdown += `| ${ticket.title} | Failed | ${ticket.error || 'Unknown error'} |\n`;
      });
      markdown += `\n`;
    }
    
    markdown += `---\n`;
    markdown += `*Generated by Jira Ticket Creator Tool*\n`;
    
    return markdown;
  }

  // Generate text report for created tickets
  static generateTextReport(createdTickets, jiraConfig) {
    const timestamp = new Date().toLocaleString();
    const successful = createdTickets.filter(t => t.status === 'success');
    const failed = createdTickets.filter(t => t.status === 'failed');
    
    let text = `JIRA TICKET CREATION REPORT\n`;
    text += `============================\n\n`;
    text += `Generated: ${timestamp}\n`;
    text += `Project: ${jiraConfig.projectKey}\n`;
    text += `Jira URL: ${jiraConfig.url}\n`;
    text += `Created by: ${jiraConfig.email}\n\n`;
    
    text += `SUMMARY\n`;
    text += `-------\n`;
    text += `Total Processed: ${createdTickets.length}\n`;
    text += `Successful: ${successful.length}\n`;
    text += `Failed: ${failed.length}\n`;
    text += `Success Rate: ${createdTickets.length > 0 ? Math.round((successful.length / createdTickets.length) * 100) : 0}%\n\n`;
    
    if (successful.length > 0) {
      text += `SUCCESSFULLY CREATED TICKETS\n`;
      text += `============================\n\n`;
      
      successful.forEach((ticket, index) => {
        text += `${index + 1}. ${ticket.ticketKey}: ${ticket.title}\n`;
        text += `   Link: ${ticket.url}\n`;
        if (ticket.attachments && ticket.attachments.length > 0) {
          text += `   Attachments: ${ticket.attachments.length} files\n`;
        }
        text += `\n`;
      });
    }
    
    if (failed.length > 0) {
      text += `FAILED TICKETS\n`;
      text += `==============\n\n`;
      
      failed.forEach((ticket, index) => {
        text += `${index + 1}. ${ticket.title}\n`;
        text += `   Error: ${ticket.error || 'Unknown error'}\n\n`;
      });
    }
    
    text += `---\n`;
    text += `Generated by Jira Ticket Creator Tool\n`;
    
    return text;
  }

  // Download markdown report
  static downloadMarkdownReport(createdTickets, jiraConfig) {
    const content = this.generateMarkdownReport(createdTickets, jiraConfig);
    const filename = `jira-tickets-${new Date().toISOString().split('T')[0]}-${Date.now()}.md`;
    this.downloadFile(content, filename, 'text/markdown');
  }

  // Download text report  
  static downloadTextReport(createdTickets, jiraConfig) {
    const content = this.generateTextReport(createdTickets, jiraConfig);
    const filename = `jira-tickets-${new Date().toISOString().split('T')[0]}-${Date.now()}.txt`;
    this.downloadFile(content, filename, 'text/plain');
  }

  // Download file helper
  static downloadFile(content, filename, mimeType) {
    const blob = new Blob([content], { type: mimeType });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  // Save to localStorage for history
  static saveToHistory(createdTickets, jiraConfig) {
    try {
      const historyKey = 'jiraTicketHistory';
      const existingHistory = JSON.parse(localStorage.getItem(historyKey) || '[]');
      
      const newEntry = {
        id: Date.now(),
        timestamp: new Date().toISOString(),
        projectKey: jiraConfig.projectKey,
        jiraUrl: jiraConfig.url,
        email: jiraConfig.email,
        tickets: createdTickets,
        summary: {
          total: createdTickets.length,
          successful: createdTickets.filter(t => t.status === 'success').length,
          failed: createdTickets.filter(t => t.status === 'failed').length
        }
      };
      
      existingHistory.unshift(newEntry);
      
      // Keep only last 50 entries
      const trimmedHistory = existingHistory.slice(0, 50);
      
      localStorage.setItem(historyKey, JSON.stringify(trimmedHistory));
      
      return newEntry;
    } catch (error) {
      console.error('Failed to save ticket history:', error);
      return null;
    }
  }

  // Get history from localStorage
  static getHistory() {
    try {
      const historyKey = 'jiraTicketHistory';
      return JSON.parse(localStorage.getItem(historyKey) || '[]');
    } catch (error) {
      console.error('Failed to get ticket history:', error);
      return [];
    }
  }

  // Clear history
  static clearHistory() {
    try {
      localStorage.removeItem('jiraTicketHistory');
      return true;
    } catch (error) {
      console.error('Failed to clear ticket history:', error);
      return false;
    }
  }
}

export default TicketHistoryService;
